# 华颜工业SCADA系统二次开发手册

## 1. 开发概述

**华颜**（Huayan）工业SCADA系统采用模块化、可扩展的架构设计，提供了完整的二次开发支持。本手册旨在帮助开发者了解系统的扩展机制，实现自定义功能和组件，以满足特定的工业应用需求。

### 1.1 项目标识

- **项目名称**：华颜（Huayan）
- **全称**：华颜工业SCADA系统（Huayan Industrial SCADA System）
- **代码命名规范**：系统代码中的关键函数和变量使用"HY"前缀（华颜缩写）以保持一致性

### 1.2 开发环境要求

- **开发工具**：Qt Creator 11.0 或更高版本
- **Qt 版本**：Qt 6.8 LTS
- **编译器**：
  - Windows: MSVC 2022
  - Linux: GCC 11+
- **构建工具**：CMake 3.22 或更高版本
- **开发语言**：C++20, QML
- **容器化工具**：Docker 20.10+ 和 Docker Compose 1.29+

### 1.3 开发流程

1. **环境搭建**：安装Qt 6.8 LTS和必要的开发工具
2. **项目配置**：配置CMake项目，设置Qt路径
3. **模块开发**：根据需求开发自定义模块
4. **测试验证**：测试开发的功能是否正常工作
5. **集成部署**：将开发的模块集成到系统中

## 2. 系统架构

### 2.1 整体架构

系统采用分层架构设计，包括：

- **用户界面层**：QML界面和组态编辑器，新增3D可视化界面
- **业务逻辑层**：核心控制器和业务处理
- **通信驱动层**：设备通信协议实现
- **数据处理层**：实时数据处理和管理，新增时序数据库集成
- **存储层**：历史数据和配置存储，新增InfluxDB/TimescaleDB支持
- **扩展接口层**：插件和二次开发接口
- **3D渲染层**：WebGL/Three.js 3D场景渲染

### 2.2 扩展点

系统提供以下扩展点：

- **QML组件扩展**：开发自定义QML组件
- **通信驱动扩展**：开发自定义通信驱动
- **数据处理扩展**：扩展数据处理逻辑
- **脚本扩展**：通过脚本语言扩展功能
- **时序数据库扩展**：开发自定义时序数据库适配器
- **3D可视化扩展**：开发自定义3D模型和场景

## 3. QML组件开发

### 3.1 组件结构

QML组件是系统的可视化元素，位于 `qml/plugins` 目录下，按照功能分类：

- **BasicComponents**：基础组件，如指示灯、按钮等
- **IndustrialComponents**：工业组件，如阀门、储罐、仪表盘等
- **ChartComponents**：图表组件，如趋势图、柱状图等
- **ThreeDComponents**：3D组件，如3D场景、模型加载器、相机控制器等

### 3.2 创建自定义组件

#### 步骤1：创建组件文件

1. 在相应的插件目录中创建新的QML文件，例如 `CustomComponent.qml`
2. 编写组件的QML代码，定义组件的外观和行为

#### 步骤2：更新qmldir文件

在组件所在目录的 `qmldir` 文件中添加组件的声明，例如：

```
module CustomComponents

CustomComponent 1.0 CustomComponent.qml
```

#### 步骤3：构建插件

重新构建项目，系统会自动编译新的组件并将其添加到插件目录中。

### 3.3 组件示例

以下是一个自定义指示灯组件的示例：

```qml
import QtQuick 2.15

Rectangle {
    id: customIndicator
    width: 50
    height: 50
    color: active ? "#4CAF50" : "#9E9E9E"
    radius: width / 2
    border.color: "#757575"
    border.width: 2
    
    property bool active: false
    property string tagName: ""
    
    // 标签值绑定
    Connections {
        target: tagManager
        function onTagValueChanged(tagName, value) {
            if (customIndicator.tagName === tagName) {
                customIndicator.active = value;
            }
        }
    }
}
```

### 3.4 组件属性

自定义组件可以定义以下类型的属性：

- **基本属性**：位置、大小、颜色等
- **数据绑定属性**：与系统标签绑定的属性
- **行为属性**：控制组件行为的属性
- **外观属性**：控制组件外观的属性

## 4. 通信驱动开发

### 4.1 驱动架构

系统的通信驱动采用插件架构，基于 `DriverBase` 抽象类实现。内置驱动包括：

- **ModbusDriver**：Modbus TCP协议实现

### 4.2 创建自定义驱动

#### 步骤1：继承DriverBase类

创建新的驱动类，继承自 `DriverBase` 抽象类：

```cpp
class CustomDriver : public DriverBase {
public:
    CustomDriver(QObject *parent = nullptr);
    
    bool connect() override;
    void disconnect() override;
    QVariant read(const QString &address) override;
    bool write(const QString &address, const QVariant &value) override;
    bool isConnected() const override;
};
```

#### 步骤2：实现驱动接口

实现 `DriverBase` 类定义的纯虚函数：

- **connect()**：建立与设备的连接
- **disconnect()**：断开与设备的连接
- **read()**：从设备读取数据
- **write()**：向设备写入数据
- **isConnected()**：检查连接状态

#### 步骤3：注册驱动

在系统启动时注册自定义驱动：

```cpp
// 在main.cpp中注册驱动
DriverManager::instance()->registerDriver("Custom", []() -> DriverBase* {
    return new CustomDriver();
});
```

### 4.3 驱动示例

以下是一个简单的自定义驱动示例：

```cpp
#include "driverbase.h"

class CustomDriver : public DriverBase {
public:
    CustomDriver(QObject *parent = nullptr) : DriverBase(parent), m_connected(false) {}
    
    bool connect() override {
        // 实现连接逻辑
        m_connected = true;
        return true;
    }
    
    void disconnect() override {
        // 实现断开连接逻辑
        m_connected = false;
    }
    
    QVariant read(const QString &address) override {
        // 实现读取逻辑
        return QVariant(0);
    }
    
    bool write(const QString &address, const QVariant &value) override {
        // 实现写入逻辑
        return true;
    }
    
    bool isConnected() const override {
        return m_connected;
    }
    
private:
    bool m_connected;
};
```

## 5. 数据处理扩展

### 5.1 数据处理架构

数据处理模块位于 `src/core` 目录下，包括：

- **TagManager**：标签管理和数据绑定
- **DataProcessor**：数据采集和处理
- **AlarmManager**：报警检测和管理

### 5.2 扩展数据处理

#### 扩展TagManager

可以通过继承 `TagManager` 类扩展标签管理功能：

```cpp
class CustomTagManager : public TagManager {
public:
    CustomTagManager(QObject *parent = nullptr) : TagManager(parent) {}
    
    // 扩展标签管理功能
    void customTagOperation(const QString &tagName) {
        // 自定义标签操作
    }
};
```

#### 扩展DataProcessor

可以通过继承 `DataProcessor` 类扩展数据处理功能：

```cpp
class CustomDataProcessor : public DataProcessor {
public:
    CustomDataProcessor(QObject *parent = nullptr) : DataProcessor(parent) {}
    
    // 扩展数据处理功能
    QVariant processCustomData(const QVariant &rawData) {
        // 自定义数据处理
        return rawData;
    }
};
```

## 6. 脚本扩展

### 6.1 脚本支持

系统支持通过脚本语言扩展功能，包括：

- **Python**：通过Python脚本扩展功能
- **Lua**：通过Lua脚本扩展功能

### 6.2 脚本API

系统提供以下脚本API：

- **标签操作**：读取和修改标签值
- **设备操作**：与设备通信
- **界面操作**：控制界面元素
- **系统操作**：系统配置和管理
- **时序数据库操作**：查询和分析历史数据

### 6.3 脚本示例

以下是一个Python脚本示例，用于监控温度并触发报警：

```python
# 温度监控脚本

def check_temperature():
    # 读取温度标签值
    temp = tag_manager.read_tag("Temperature")
    
    # 检查温度是否超过阈值
    if temp > 80:
        # 触发报警
        alarm_manager.trigger_alarm("Temperature High", "温度超过阈值", "High")
        # 发送通知
        notification_manager.send_email("admin@example.com", "温度报警", f"当前温度: {temp}°C")

# 定时执行
import time
while True:
    check_temperature()
    time.sleep(10)  # 每10秒检查一次
```

## 7. 时序数据库集成

### 7.1 时序数据库架构

系统集成了时序数据库支持，位于 `src/core` 目录下：

- **TimeSeriesDatabase**：时序数据库抽象类
- **InfluxDBDatabase**：InfluxDB实现
- **TimescaleDBDatabase**：TimescaleDB实现

### 7.2 开发自定义时序数据库适配器

#### 步骤1：继承TimeSeriesDatabase类

创建新的时序数据库适配器类，继承自 `TimeSeriesDatabase` 抽象类：

```cpp
class CustomTimeSeriesDatabase : public TimeSeriesDatabase {
public:
    CustomTimeSeriesDatabase(QObject *parent = nullptr);
    
    bool connect() override;
    void disconnect() override;
    bool writeTagValue(const QString &tagName, const QVariant &value, const QDateTime &timestamp) override;
    QVariantList queryTagValues(const QString &tagName, const QDateTime &startTime, const QDateTime &endTime) override;
    bool isConnected() const override;
};
```

#### 步骤2：实现数据库接口

实现 `TimeSeriesDatabase` 类定义的纯虚函数：

- **connect()**：建立与数据库的连接
- **disconnect()**：断开与数据库的连接
- **writeTagValue()**：写入标签值到时序数据库
- **queryTagValues()**：查询标签的历史值
- **isConnected()**：检查连接状态

#### 步骤3：注册数据库适配器

在系统启动时注册自定义数据库适配器：

```cpp
// 在main.cpp中注册数据库适配器
TimeSeriesDatabaseManager::instance()->registerDatabaseAdapter("Custom", []() -> TimeSeriesDatabase* {
    return new CustomTimeSeriesDatabase();
});
```

### 7.3 时序数据库示例

以下是一个简单的自定义时序数据库适配器示例：

```cpp
#include "timeseriesdatabase.h"

class CustomTimeSeriesDatabase : public TimeSeriesDatabase {
public:
    CustomTimeSeriesDatabase(QObject *parent = nullptr) : TimeSeriesDatabase(parent), m_connected(false) {}
    
    bool connect() override {
        // 实现连接逻辑
        m_connected = true;
        return true;
    }
    
    void disconnect() override {
        // 实现断开连接逻辑
        m_connected = false;
    }
    
    bool writeTagValue(const QString &tagName, const QVariant &value, const QDateTime &timestamp) override {
        // 实现写入逻辑
        return true;
    }
    
    QVariantList queryTagValues(const QString &tagName, const QDateTime &startTime, const QDateTime &endTime) override {
        // 实现查询逻辑
        return QVariantList();
    }
    
    bool isConnected() const override {
        return m_connected;
    }
    
private:
    bool m_connected;
};
```

## 8. 插件系统

### 8.1 插件结构

系统的插件位于 `qml/plugins` 目录下，每个插件是一个独立的模块，包含：

- **qmldir**：插件的元数据文件
- **QML文件**：插件提供的组件
- **CMakeLists.txt**：插件的构建配置

### 8.2 创建自定义插件

#### 步骤1：创建插件目录

在 `qml/plugins` 目录下创建新的插件目录，例如 `CustomPlugins`。

#### 步骤2：创建插件文件

1. 创建 `qmldir` 文件，定义插件的模块名称和组件
2. 创建 `CMakeLists.txt` 文件，配置插件的构建
3. 创建 QML 组件文件

#### 步骤3：配置CMake

在插件目录的 `CMakeLists.txt` 文件中配置插件的构建：

```cmake
cmake_minimum_required(VERSION 3.22)

project(CustomPlugins LANGUAGES CXX)

set(CMAKE_AUTOMOC ON)
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

find_package(Qt6 REQUIRED COMPONENTS Core Qml)

qt_add_qml_module(CustomPlugins
    URI CustomPlugins
    VERSION 1.0
    QML_FILES
        CustomComponent.qml
    RESOURCES
        qmldir
)

target_link_libraries(CustomPlugins PRIVATE Qt6::Core Qt6::Qml)
```

#### 步骤4：构建插件

重新构建项目，系统会自动编译新的插件并将其添加到插件目录中。

## 9. 3D可视化开发

### 9.1 3D可视化架构

系统的3D可视化功能基于WebGL和Three.js，位于 `qml/plugins/ThreeDComponents` 目录下：

- **ThreeDScene**：3D场景组件
- **ModelLoader**：3D模型加载组件
- **CameraController**：相机控制组件

### 9.2 开发自定义3D组件

#### 步骤1：创建3D组件文件

在 `qml/plugins/ThreeDComponents` 目录中创建新的QML文件，例如 `Custom3DObject.qml`。

#### 步骤2：编写3D组件代码

使用Three.js API编写3D组件的QML代码：

```qml
import QtQuick 2.15
import ThreeDComponents 1.0

Item {
    id: custom3DObject
    width: 400
    height: 300
    
    property string modelPath: ""
    property real scale: 1.0
    property real rotationX: 0
    property real rotationY: 0
    property real rotationZ: 0
    
    ThreeDScene {
        id: scene
        anchors.fill: parent
        
        // 加载3D模型
        onSceneCreated: {
            if (modelPath) {
                loadModel(modelPath);
            } else {
                // 创建默认立方体
                createCube();
            }
        }
        
        // 应用变换
        Component.onCompleted: {
            scene.scaleObject(root.objectId, scale);
            scene.rotateObject(root.objectId, rotationX, rotationY, rotationZ);
        }
    }
    
    // 暴露场景对象ID
    property string objectId: scene.objectId
}
```

#### 步骤3：更新qmldir文件

在 `qml/plugins/ThreeDComponents/qmldir` 文件中添加组件的声明：

```
Custom3DObject 1.0 Custom3DObject.qml
```

#### 步骤4：构建和测试

重新构建项目，然后在配置编辑器中使用新的3D组件。

### 9.3 3D模型格式

系统支持以下3D模型格式：

- **GLB**：二进制GLTF格式，推荐使用
- **GLTF**：JSON格式的GLTF
- **OBJ**：Wavefront OBJ格式
- **FBX**：Autodesk FBX格式

### 9.4 性能优化

开发3D组件时，应注意以下性能优化事项：

- **模型简化**：使用简化的3D模型，减少多边形数量
- **纹理优化**：使用适当大小的纹理，避免过大的纹理
- **LOD**：实现细节层次（Level of Detail），根据距离调整模型复杂度
- **批处理**：合并多个3D对象的渲染，减少绘制调用
- **缓存**：缓存常用的3D模型和材质

### 9.5 3D场景示例

以下是一个简单的3D工厂场景示例：

```qml
import QtQuick 2.15
import ThreeDComponents 1.0

Item {
    id: factoryScene
    width: 800
    height: 600
    
    ThreeDScene {
        id: scene
        anchors.fill: parent
        
        // 创建工厂场景
        onSceneCreated: {
            // 添加地面
            createGround();
            
            // 添加建筑物
            createBuilding();
            
            // 添加设备
            createEquipment();
            
            // 添加灯光
            addLighting();
        }
    }
    
    // 场景控制
    CameraController {
        id: cameraController
        scene: scene
        initialPosition: Qt.vector3d(10, 10, 10)
        targetPosition: Qt.vector3d(0, 0, 0)
    }
}
```

## 10. 配置与部署

### 10.1 配置文件

系统的配置文件位于 `bin/config` 目录下，包括：

- **system.json**：系统基本配置
- **drivers.json**：驱动配置
- **tags.json**：标签配置
- **layout.json**：界面布局配置

### 10.2 部署自定义模块

#### 部署QML组件

1. 将编译好的QML组件复制到 `bin/qml` 目录下
2. 更新 `qmldir` 文件
3. 重启系统，系统会自动加载新的组件

#### 部署通信驱动

1. 将编译好的驱动库复制到 `bin/plugins` 目录下
2. 更新 `drivers.json` 配置文件
3. 重启系统，系统会自动加载新的驱动

### 10.3 版本管理

在开发过程中，建议使用版本控制系统（如Git）管理代码，遵循以下原则：

- **分支管理**：使用分支开发新功能
- **代码审查**：在合并代码前进行代码审查
- **版本标记**：为重要版本创建标记
- **文档更新**：同步更新相关文档

## 11. 开发工具与技巧

### 11.1 开发工具

- **Qt Creator**：主要开发环境
- **QML Designer**：QML界面设计工具
- **CMake**：项目构建工具
- **调试器**：代码调试工具

### 11.2 开发技巧

- **模块化设计**：将功能分解为小的、可管理的模块
- **代码复用**：重用现有的代码和组件
- **错误处理**：添加适当的错误处理和日志
- **性能优化**：优化代码性能，特别是实时数据处理部分
- **测试驱动**：先编写测试，再实现功能

### 11.3 常见问题

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| QML组件未找到 | 插件未正确编译 | 检查插件的CMake配置和构建过程 |
| 驱动加载失败 | 驱动实现有问题 | 检查驱动的实现和依赖 |
| 数据处理错误 | 数据处理逻辑有问题 | 检查数据处理代码和错误处理 |
| 性能问题 | 代码效率低 | 优化代码，特别是循环和频繁操作 |

## 12. 示例项目

### 12.1 自定义组件示例

以下是一个自定义储罐组件的开发示例：

#### 步骤1：创建组件文件

在 `qml/plugins/IndustrialComponents` 目录中创建 `CustomTank.qml` 文件：

```qml
import QtQuick 2.15

Rectangle {
    id: customTank
    width: 120
    height: 180
    color: "#E0E0E0"
    border.color: "#9E9E9E"
    border.width: 2
    
    property real level: 0.5
    property string tagName: ""
    
    // 储罐液体
    Rectangle {
        id: liquid
        width: parent.width - 10
        height: parent.height * level
        color: "#2196F3"
        anchors.bottom: parent.bottom
        anchors.horizontalCenter: parent.horizontalCenter
        anchors.margins: 5
        opacity: 0.8
    }
    
    // 液位指示器
    Rectangle {
        width: 5
        height: parent.height - 10
        color: "#BDBDBD"
        anchors.right: parent.right
        anchors.rightMargin: 5
        anchors.verticalCenter: parent.verticalCenter
        
        Rectangle {
            width: 8
            height: 8
            color: "#F44336"
            anchors.horizontalCenter: parent.horizontalCenter
            y: parent.height - (parent.height * level) - 4
        }
    }
    
    // 标签值绑定
    Connections {
        target: tagManager
        function onTagValueChanged(tagName, value) {
            if (customTank.tagName === tagName) {
                customTank.level = value;
            }
        }
    }
}
```

#### 步骤2：更新qmldir文件

在 `qml/plugins/IndustrialComponents/qmldir` 文件中添加：

```
CustomTank 1.0 CustomTank.qml
```

#### 步骤3：构建和测试

重新构建项目，然后在配置编辑器中使用新的自定义储罐组件。

### 12.2 自定义驱动示例

以下是一个自定义Modbus RTU驱动的开发示例：

#### 步骤1：创建驱动文件

在 `src/communication` 目录中创建 `modbusrtudriver.h` 和 `modbusrtudriver.cpp` 文件：

#### modbusrtudriver.h

```cpp
#ifndef MODBUSRTUDRIVER_H
#define MODBUSRTUDRIVER_H

#include "driverbase.h"
#include <QSerialPort>

class ModbusRtuDriver : public DriverBase {
    Q_OBJECT

public:
    ModbusRtuDriver(QObject *parent = nullptr);
    ~ModbusRtuDriver();
    
    bool connect() override;
    void disconnect() override;
    QVariant read(const QString &address) override;
    bool write(const QString &address, const QVariant &value) override;
    bool isConnected() const override;
    
    void setSerialPort(const QString &port);
    void setBaudRate(int baudRate);
    void setParity(QSerialPort::Parity parity);
    void setDataBits(int dataBits);
    void setStopBits(QSerialPort::StopBits stopBits);
    void setSlaveAddress(int address);
    
private:
    QSerialPort *m_serialPort;
    int m_slaveAddress;
    bool m_connected;
};

#endif // MODBUSRTUDRIVER_H
```

#### modbusrtudriver.cpp

```cpp
#include "modbusrtudriver.h"

ModbusRtuDriver::ModbusRtuDriver(QObject *parent) 
    : DriverBase(parent), 
      m_serialPort(new QSerialPort(this)), 
      m_slaveAddress(1), 
      m_connected(false) {
}

ModbusRtuDriver::~ModbusRtuDriver() {
    disconnect();
    delete m_serialPort;
}

bool ModbusRtuDriver::connect() {
    if (m_serialPort->isOpen()) {
        return true;
    }
    
    m_serialPort->open(QIODevice::ReadWrite);
    if (m_serialPort->isOpen()) {
        m_connected = true;
        return true;
    }
    
    return false;
}

void ModbusRtuDriver::disconnect() {
    if (m_serialPort->isOpen()) {
        m_serialPort->close();
    }
    m_connected = false;
}

QVariant ModbusRtuDriver::read(const QString &address) {
    // 实现Modbus RTU读取逻辑
    return QVariant(0);
}

bool ModbusRtuDriver::write(const QString &address, const QVariant &value) {
    // 实现Modbus RTU写入逻辑
    return true;
}

bool ModbusRtuDriver::isConnected() const {
    return m_connected;
}

void ModbusRtuDriver::setSerialPort(const QString &port) {
    m_serialPort->setPortName(port);
}

void ModbusRtuDriver::setBaudRate(int baudRate) {
    m_serialPort->setBaudRate(baudRate);
}

void ModbusRtuDriver::setParity(QSerialPort::Parity parity) {
    m_serialPort->setParity(parity);
}

void ModbusRtuDriver::setDataBits(int dataBits) {
    m_serialPort->setDataBits(static_cast<QSerialPort::DataBits>(dataBits));
}

void ModbusRtuDriver::setStopBits(QSerialPort::StopBits stopBits) {
    m_serialPort->setStopBits(stopBits);
}

void ModbusRtuDriver::setSlaveAddress(int address) {
    m_slaveAddress = address;
}
```

#### 步骤2：注册驱动

在 `main.cpp` 文件中注册新的驱动：

```cpp
// 注册Modbus RTU驱动
DriverManager::instance()->registerDriver("ModbusRTU", []() -> DriverBase* {
    return new ModbusRtuDriver();
});
```

#### 步骤3：构建和测试

重新构建项目，然后在系统设置中配置和使用新的Modbus RTU驱动。

## 13. 结论与建议

### 13.1 开发建议

- **循序渐进**：从简单的功能开始，逐步开发复杂的功能
- **文档先行**：在开发前编写详细的设计文档
- **测试覆盖**：为开发的功能编写充分的测试
- **用户反馈**：收集用户反馈，不断改进功能
- **持续学习**：关注Qt和工业自动化领域的最新技术

### 13.2 最佳实践

- **代码风格**：遵循Qt的代码风格和命名约定
- **文档注释**：为代码添加详细的注释和文档
- **错误处理**：添加适当的错误处理和异常捕获
- **性能考虑**：优化代码性能，特别是实时数据处理
- **安全性**：考虑系统的安全性，特别是在网络通信方面

### 13.3 未来展望

随着工业4.0的发展，SCADA系统将面临新的挑战和机遇：

- **物联网集成**：与更多的物联网设备集成
- **大数据分析**：利用大数据技术分析工业数据
- **人工智能**：应用人工智能技术优化工业过程
- **云服务**：提供云服务和远程监控
- **边缘计算**：在边缘设备上处理数据

通过持续的开发和创新，华颜工业SCADA系统将不断适应工业自动化的发展需求，为用户提供更加先进、可靠的工业监控解决方案。

## 14. 附录

### 14.1 参考资源

- **Qt文档**：https://doc.qt.io/
- **Modbus协议文档**：https://modbus.org/
- **OPC UA文档**：https://opcfoundation.org/
- **工业自动化标准**：https://www.isa.org/

### 14.2 联系方式

- **技术支持**：support@huayan-scada.com
- **开发者论坛**：forum.huayan-scada.com
- **GitHub仓库**：https://github.com/huayan-scada

---

本手册由华颜软件技术团队编制，如有任何疑问或建议，请联系我们。

© 2026 华颜软件 保留所有权利。